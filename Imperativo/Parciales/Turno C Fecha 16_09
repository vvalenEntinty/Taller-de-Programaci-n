program ejercicio;
const
	cod_fin=0;
type
	rango_dia=1..31;
	rango_mes=1..12;
	
	envio=record
		cod_cliente:integer;
		dia:rango_dia;
		mes:rango_mes;
		cod_postal:integer;
		peso:real;
	end;
	
	vector=array[rango_mes] of integer;
	
	regArbol=record
		cod_postal:integer;
		vector:vector;
	end;
	
	arbol=^nodo;
	nodo=record
		dato:regArbol;
		HI:arbol;
		HD:arbol;
	end;
	
procedure cargarArbol (var a:arbol);

procedure inicializarVector (var v:vector);
var
	i:rango_mes;
begin
	for i := 1 to 12 do
		v[i]:=0;
end;

procedure leerEnvio(var e:envio);
begin
    e.cod_Cliente:= random(800);
    if(e.cod_Cliente <> cod_fin)then begin
            e.dia:= 1+random(31-1+1);
            e.mes:= 1+ random(12-1+1);
            e.cod_Postal:= random(10);
            e.peso:= random(20000)/ (random(10 )+1);
    end;
end;

procedure insertarArbol (var a:arbol; postal,mes:integer);
begin
	if (a=nil) then
	begin
		new(a);
		a^.dato.cod_postal:=postal;
		inicializarVector(a^.dato.vector);
		a^.dato.vector[mes]:=a^.dato.vector[mes] +1;
		a^.HI:=nil;
		a^.HD:=nil;
	end
	else if (postal = a^.dato.cod_postal) then
		a^.dato.vector[mes]:=a^.dato.vector[mes] +1
		
		else if (postal < a^.dato.cod_postal) then
			insertarArbol(a^.HI,postal,mes)
			else
				insertarArbol(a^.HD,postal,mes);
end;
var
	e:envio;
begin
	leerEnvio(e);
	while (e.cod_cliente <> cod_fin) do
	begin
		insertarArbol(a,e.cod_postal,e.mes);
		leerEnvio(e);
	end;
end;
	
procedure imprimirVector (v:vector);
var
	i:integer;
begin
	for i := 1 to 12 do 
		writeln('Mes: ',i,' cantidad de envios: ',v[i]);
end;

procedure imprimirArbol (a:arbol);
begin
	if (a<>nil) then
	begin
		imprimirArbol(a^.HI);
		writeln('');
		writeln('[ --- Codigo postal: ',a^.dato.cod_postal, ' --- ]');
		imprimirVector(a^.dato.vector);
		imprimirArbol(a^.HD);
	end;
end;

procedure buscarCodPostal (a:arbol; codB,valorB:integer; var cant:integer);

function recorrerVector (v:vector; valor:integer):integer;
var
	i:rango_mes;
	cant:integer;
begin
	cant:=0;
	for i := 1 to 12 do
		if (v[i]>valor) then
			cant:=cant+1;
	recorrerVector:=cant;
end;

begin
	if (a <> nil ) then
	begin
		if (a^.dato.cod_postal = codB) then
			cant:=recorrerVector(a^.dato.vector,valorB)
			else
				if (a^.dato.cod_postal>codB) then	
					buscarCodPostal(a^.HI,codB,valorB,cant)
					else
						buscarCodPostal(a^.HD,codB,valorB,cant)
	end;
end;

procedure buscarEntrePostales (a:arbol; min,max:integer);

function buscarSinEnvio(v:vector):boolean;
var
	esta:boolean;
	i:integer;
begin
	esta:=false;
	i:=1;
	while (i<=12) and (not esta) do
	begin
		if (v[i] = 0) then
			esta:=true;
		i:=i+1;
	end;
	buscarSinEnvio:=esta;
end;

begin
	if (a<>nil) then 
	begin
		if (a^.dato.cod_postal >= min) then 
		begin
			if(a^.dato.cod_postal <= max) then 
			begin
				if (buscarSinEnvio(a^.dato.vector))then
				begin
					buscarEntrePostales(a^.HI,min,max);
					writeln('Postal que tuvo un mes sin envio: ',a^.dato.cod_postal);
					buscarEntrePostales(a^.HD,min,max);
				end
				else 
				begin
					buscarEntrePostales(a^.HI,min,max);
					writeln('La postal ',a^.dato.cod_postal, ' tiene envios en todos sus meses');
					buscarEntrePostales(a^.HD,min,max);
				end;
			end
			else
				buscarEntrePostales(a^.HI,min,max);
		end
		else
			buscarEntrePostales(a^.HD,min,max);
	end;
end;
	
// PROGRAMA PRINCIPAL
var
	a:arbol;
	cant,codB,valorB:integer;
	posMin,posMax:integer;
begin	
	a:=nil;
	randomize;
	cargarArbol(a);
	imprimirArbol (a);
	writeln('');
	writeln('Ingresar un codigo postal'); readln(codB);
	writeln('Ingresar un valor');readln(valorB);
	buscarCodPostal(a,codB,valorB,cant);
	writeln('La cantidad de meses cuya cantidad supera al valor ingresado es: ',cant);
	writeln('');
	writeln('Ingresar codigo de postal A');readln(posMin);
	writeln('Ingresar codigo de postal B');readln(posMax);
	buscarEntrePostales(a,posMin,posMax);
end.
